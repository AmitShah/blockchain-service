

# Gonetwork Framework 

![High Level Architecture](https://github.com/gonetwork-project/gonetwork-framework/issues/25?raw=true "Architecture")

Consolidated framework with state channel engine, blockchain service, and transport layer implementation.

GoNetwork Documentations [WIP] : https://gonetwork.co/docs/Engine.html

[TODO: functionalities provided]

## Overview of provided components

### Engine / State Channel Service

[TODO]

### GoNetwork Blockchain Service

The BlockChain service is written as a standalone library that provides full offchain support for transactions and `JSON RPC` calls. The service is written as a lightweight library for use in various projects. We implement a subset of https://github.com/ethereum/wiki/wiki/JSON-RPC and include wrappers around the smart-contracts in use for state-channel implementation. All signing is handled by the library and generates the appropriate `JSON RPC` payloads that can be sent to any `JSON RPC` compatible node.  There is minimal trust in the `JSON RPC` node servicing your request beyond the fact that it will distribute your message as your `private key` and signing is handled in the application context running the library.

When making eth_call functions however, you need to be more weary (in general) of the communication endpoint as results can be easily spoofed.

This library will work well in conjunction with standard Geth HTTP Gateway Providers/Apis; Infura, EtherScan, etc.

#### [src/blockchain/rpc.ts](src/blockchain/rpc.ts)

A very light, but type safe implementation for interacting with `JSON RPC` eth nodes. It provides commands needed for the `monitoring module` (e.g. obtaining current block number and logs for specific address) and interacting with smart contracts themselves.

#### [src/blockchain/contracts-proxy.ts](src/blockchain/contracts-proxy.ts)

A wrapper over the `rpc module` for interacting with deploy smart contracts in a type safe manner. It consumes the minimal information generated by automatic analyzing of contract's `abi` [link to generator script](dev/scripts/abi-to-ts.ts) and offers support for all methods defined in the abi. In case of transactions and in addition to basic interactions which require provided all information manually, the module can automatically obtain all necessary information (`nonce`, `gas price`, `gas estimation`) before committing the transaction itself.  

It is very generic in nature and could be easily re-used in different contexts with different smart contracts.

One caveat is that at current version it does not support deploying smart contracts.

#### [src/blockchain/monitoring.ts](src/blockchain/monitoring.ts)

A module for monitoring events related to addresses of interest, current block number and state of a transaction (based on `TxHash`). The implementation aims at efficiency - e.g. monitoring logs is in done with a single request.

### [src/p2p/p2p.ts](src/blockchain/monitoring.ts)

A self-contained module for handling peer-2-peer interactions with using mqtt protocol. It keeps a queue of messages, which are sent one by one to the other and. It supports very basic discovery protocol: when peer becomes online it pings all known peers.

## Setup

Architecture aims at modularity, therefore some manual setup is required to initialize the `engine module`. Current assumption is that engine will support a set of pre-deployed contracts with known addresses.

*Caveat* The below is not a final version of the api and most likely will change in the future.

An example setup could look like following:

```typescript
import {
  Engine, serviceCreate, P2P,  fakeStorage, CHAIN_ID
} from 'go-network-framework'


const p2p = new P2P({
  mqttUrl: cfg.mqttUrl,
  address: account.addressStr, // address of the account is as well an address of the peer
  storage: fakeStorage() // p2p requires some level of persistency but it is not supported in other parts
})


// underneath it initializes all required modules: `monitoring`, `contracts-proxy` and `rpc`
const blockchain = serviceCreate({
  owner: account.address,
  // following three addresses must be pre-deployed
  manager: managerAddress,
  testToken: erc20TokenAddress, // the `testToken` name will be changed to something more meaningful and most likely more than one address could be provided
  gotToken: gonetworkTokenAddress,
  chainId: CHAIN_ID.GETH_PRIVATE_CHAINS, // 1337 - local network
  signatureCb: (cb) => cb(account.privateKey),
  providerUrl: cfg.ethUrl, // Eth `JSON RPC` compatible node 
  monitoringConfig: {
    startBlock: 'latest', // 'earliest' would be more appropriate to reconstruct the state, but then we need proper persistence support
      logsInterval: cfg.blockTime // cfg.blockTime
    }
  })

// initializing engine
const engine = new Engine({
  address: account.address,
  sign: (msg) => msg.sign(account.privateKey),
  send: (to, msg) =>  p2p.send(to.toString('hex'), message.serialize(msg)),
  blockchain: blockchain,
  // currently engine assumes single value for all contracts
  settleTimeout: timeouts.settle, // number of blocks after channel closed
  revealTimeout: timeouts.reveal // [TODO: describe in one sentence :)]
})

// connect blockchain and p2p instances with engine
blockchain.monitoring.on('*', engine.onBlockchainEvent)
p2p.on('message-received', msg => engine.onMessage(message.deserializeAndDecode(msg) as any))
```

`p2p` and `monitoring` modules runs long running jobs. Once you are done you should dispose them like that:

```typescript
p2p.dispose()
blockchain.monitoring.dispose()
```

## Tests

There are two forms of tests that are available to run: integration tests and component tests. Tests assumes some pre-deployed contracts present on the test server.

As a first step you need to start local ganache instance and mqtt server - with `npm run dev`.

To run integration tests: `npm run test-inte` and component tests: `npm run test-unit`. Remember to restart the dev server if you switch between these types of tests, as the tests use hard coded addresses which _may_ overlap and cause the tests to fail.

## Production

Deploying to production
To release your framework code in production, consult gonetwork for available ERC20 token support and corresponding ChannelManager addresses.
